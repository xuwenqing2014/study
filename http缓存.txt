http缓存包括强制缓存和协商缓存。
强制缓存是指强制使用缓存，协商缓存是指每一次需要去询问，用不用本地缓存。
强缓存，状态码是200
1、http 1.0 expires 设置的是过期的绝对时间，依赖于本地时间，所以本地时间出问题了，缓存时间的过期时间也出问题了，所以这是个缺陷，才出现了cache-control
2、http 1.1 cache-control 
取值可以好几个一起
     no-cache 不使用强制缓存，使用协商缓存
     no-store  不使用协商缓存，也不使用强制缓存
     max-age 缓存的过期时间，单位是s 秒
     private    默认，私有缓存，客户端可以缓存，代理服务器不能缓存
     public     共有缓存，客户端和代理服务器都可以缓存

协商缓存，状态码是304
第一次请求的时候，服务通过Last-Modified的响应头将缓存标识给客户端，第二次请求的时候，客户端会将缓存标识一并传给服务器，服务器会判断资源是否已经改变，如果改变的话会返回200，如果没改变的话会返回304，客户端使用协商缓存。
1、http 1.0 Last-Modified If-Modified-Since
2、http1.1  Etag If-None-Match

Last-Modified If-Modified-Since
第一次请求的时候，服务器会将资源在服务器中最后一次修改的时间返回给客户端，客户端再下次请求的时候，会将服务端上一次返回的Last-Modified的时间作为If-Modified-Since 的参数发送到服务端，
服务端会根据这个时间，来确定是否是，使用协商缓存304，还是返回新资源200
弊端：If-Modified-Since无法正确感知到文件的变化，例如，文件编辑了，但是内容并没有变化，服务端还是按照编辑时间去判断，返回了新资源。例如在很短的时间内，修改了文件，但是If-Modified-Since只能感知到秒级的变化，这个时候，并没有返回新文件。
所以才出现了Etag和If-None-Match。

Etag和If-None-Match

第一次请求时，服务端会返回一个Etag的标识符，用来标识文件的字符串，只要文件修改了，Etag就会重新生成
在第二次请求时，会将上一次的Etag的值作为If-None-Match的参数发送给服务端，服务端会根据Etag的值是否改变，来确定是否返回新资源
